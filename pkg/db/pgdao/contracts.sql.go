// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: contracts.sql

package pgdao

import (
	"context"
	"database/sql"
)

const contractAdd = `-- name: ContractAdd :one
insert into contracts (
    id, customer_id, performer_id, application_id, title, description, price, duration, created_by
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
returning id, customer_id, performer_id, application_id, title, description, price, duration, status, created_by, created_at, updated_at
`

type ContractAddParams struct {
	ID            string
	CustomerID    string
	PerformerID   string
	ApplicationID string
	Title         string
	Description   string
	Price         string
	Duration      sql.NullInt32
	CreatedBy     string
}

func (q *Queries) ContractAdd(ctx context.Context, arg ContractAddParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, contractAdd,
		arg.ID,
		arg.CustomerID,
		arg.PerformerID,
		arg.ApplicationID,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Duration,
		arg.CreatedBy,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.PerformerID,
		&i.ApplicationID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Duration,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const contractGet = `-- name: ContractGet :one
select c.id, c.customer_id, c.performer_id, c.application_id, c.title, c.description, c.price, c.duration, c.status, c.created_by, c.created_at, c.updated_at from contracts c
join applications a on a.id = c.application_id and a.applicant_id = c.performer_id
join jobs j on j.id = a.job_id
join persons customer on customer.id = c.customer_id
join persons performer on performer.id = c.performer_id
where c.id = $1::varchar
`

// mostly in testing purposes
func (q *Queries) ContractGet(ctx context.Context, id string) (Contract, error) {
	row := q.db.QueryRowContext(ctx, contractGet, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.PerformerID,
		&i.ApplicationID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Duration,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const contractGetByIDAndPersonID = `-- name: ContractGetByIDAndPersonID :one
select c.id, c.customer_id, c.performer_id, c.application_id, c.title, c.description, c.price, c.duration, c.status, c.created_by, c.created_at, c.updated_at from contracts c
join applications a on a.id = c.application_id and a.applicant_id = c.performer_id
join jobs j on j.id = a.job_id
join persons customer on customer.id = c.customer_id
join persons performer on performer.id = c.performer_id
where c.id = $1::varchar and (c.customer_id = $2::varchar or c.performer_id = $2::varchar)
`

type ContractGetByIDAndPersonIDParams struct {
	ID       string
	PersonID string
}

func (q *Queries) ContractGetByIDAndPersonID(ctx context.Context, arg ContractGetByIDAndPersonIDParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, contractGetByIDAndPersonID, arg.ID, arg.PersonID)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.PerformerID,
		&i.ApplicationID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Duration,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const contractSetStatus = `-- name: ContractSetStatus :exec
update contracts c set status = $1::varchar, updated_at = now()
where c.id = $2::varchar
`

type ContractSetStatusParams struct {
	NewStatus string
	ID        string
}

func (q *Queries) ContractSetStatus(ctx context.Context, arg ContractSetStatusParams) error {
	_, err := q.db.ExecContext(ctx, contractSetStatus, arg.NewStatus, arg.ID)
	return err
}

const contractsGetByPerson = `-- name: ContractsGetByPerson :many
select id, customer_id, performer_id, application_id, title, description, price, duration, status, created_by, created_at, updated_at from contracts
where customer_id = $1::varchar or performer_id = $1::varchar
`

func (q *Queries) ContractsGetByPerson(ctx context.Context, personID string) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, contractsGetByPerson, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.PerformerID,
			&i.ApplicationID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Duration,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contractsPurge = `-- name: ContractsPurge :exec
DELETE FROM contracts
`

// Handle with care!
func (q *Queries) ContractsPurge(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, contractsPurge)
	return err
}
